C51 COMPILER V9.57.0.0   8SEG                                                              05/27/2020 23:04:35 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE 8SEG
OBJECT MODULE PLACED IN ..\OBJ\8seg.obj
COMPILER INVOKED BY: e:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\8seg.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\HARDWARE) DEBUG OB
                    -JECTEXTEND PRINT(.\Listings\8seg.lst) OBJECT(..\OBJ\8seg.obj)

line level    source

   1          #include "8seg.h"
   2          
   3          #ifdef CA
   4          // 共阳数码管段选，0 ~ F & . & 空
   5          uchar code SegSel_CA[] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 
   6                                                            0x82, 0xF8, 0x80, 0x90, 0x88, 0x83, 
   7                                                            0xC6, 0xA1, 0x86, 0x8E, 0x7F, 0xFF};
   8          #elif defined CC
              // 为了方便查阅才写出来，也可以直接CA的段选取反
              uchar code SegSel_CC[] = {0x3F, 0x06, 0x5B, 0x4F, 0x66, 0x6D, 
                                                                0x7D, 0x07, 0x7F, 0x6F, 0x77, 0x7C, 
                                                                0x39, 0x5E, 0x79, 0x71, 0x80, 0x00};
              #endif
  14          
  15          // 数码管的位选                                           
  16          uchar code SegBit[]    = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
  17          
  18          void LED_8Seg_Delay(uchar t)
  19          {
  20   1              while(t--);
  21   1      }
  22          
  23          #ifdef CA
  24          /* 这个函数定义的是8位的显示，传入的参数：
  25             1. 是要显示的字符串，占8位，0~F以及不显示，字母全大写
  26             2. 8要显示小数点的状态，转化为16进制，从高到低
  27             P.S. 要显示其他字符需要修改上面段选的数组，然后补充下面if函数 */
  28          void LED_8Seg_Display(uchar disStr[8], uchar dp)
  29          {
  30   1              uchar i, disCode;
  31   1              
  32   1              for(i = 0; i < 8; i++)
  33   1              {
  34   2                      // 位选
  35   2                      LED_BIT = SegBit[i];
  36   2                      
  37   2                      // 段选
  38   2                      if(disStr[i] >= '0' && disStr[i] <= '9')
  39   2                      {
  40   3                              disCode = SegSel_CA[disStr[i] - '0'];
  41   3                      }
  42   2                      else if(disStr[i] >= 'A' && disStr[i] <= 'F')
  43   2                      {
  44   3                              disCode = SegSel_CA[disStr[i] - 'A' + 10];
  45   3                      }
  46   2                      else
  47   2                      {
  48   3                              disCode = SegSel_CA[17];
  49   3                      }
  50   2                      LED_SEG = ~(~disCode + ((dp >> (7 - i)) & 0x01) * ~SegSel_CA[16]);
  51   2                      
  52   2                      LED_8Seg_Delay(REFRESH);
  53   2                      
  54   2                      // 消隐
C51 COMPILER V9.57.0.0   8SEG                                                              05/27/2020 23:04:35 PAGE 2   

  55   2                      LED_SEG = SegSel_CA[17];
  56   2              }
  57   1      }
  58          #elif defined CC
              /* 这个函数定义的是8位的显示，传入的参数：
                 1. 是要显示的字符串，占8位，0~F以及不显示，字母全大写
                 2. 8要显示小数点的状态，转化为16进制，从高到低
                 P.S. 要显示其他字符需要修改上面段选的数组，然后补充下面if函数 */
              void LED_8Seg_Display(uchar disStr[8], uchar dp)
              {
                      uchar i, disCode;
                      
                      for(i = 0; i < 8; i++)
                      {
                              // 位选
                              LED_BIT = ~SegBit[i];
                              
                              // 段选
                              if(disStr[i] >= '0' && disStr[i] <= '9')
                              {
                                      disCode = SegSel_CC[disStr[i] - '0'];
                              }
                              else if(disStr[i] >= 'A' && disStr[i] <= 'F')
                              {
                                      disCode = SegSel_CC[disStr[i] - 'A' + 10];
                              }
                              else
                              {
                                      disCode = SegSel_CC[17];
                              }
                              LED_SEG = disCode + ((dp >> (7 - i)) & 0x01) * SegSel_CC[16];
                              
                              LED_8Seg_Delay(REFRESH);
                              
                              // 消隐
                              LED_SEG = SegSel_CC[17];
                      }
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    155    ----
   CONSTANT SIZE    =     26    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
