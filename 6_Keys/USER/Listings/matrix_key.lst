<<<<<<< HEAD
C51 COMPILER V9.57.0.0   MATRIX_KEY                                                        06/02/2020 20:38:17 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MATRIX_KEY
OBJECT MODULE PLACED IN ..\OBJ\matrix_key.obj
COMPILER INVOKED BY: e:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\matrix_key.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\HARDWARE) DE
                    -BUG OBJECTEXTEND PRINT(.\Listings\matrix_key.lst) OBJECT(..\OBJ\matrix_key.obj)

line level    source

   1          #include "matrix_key.h"
   2          
   3          // 装载当前时刻按键状态值
   4          uchar MatrixKeyCur[4][4]  = {1};
   5          // 装载之前时刻按键状态值
   6          uchar MatrixKeyPre[4][4]  = {1};
   7          // 四次按键扫描缓冲
   8          uchar MatrixKeyBuff[4][4] = {0xFF};
   9          uchar code Col_Sel[4] = {0xEF, 0xDF, 0xBF, 0x7F};
  10          
  11          void TINT0_Init()
  12          {
  13   1              // 方式1
  14   1              TMOD |= 0x01;
  15   1              // 打开定时器0
  16   1              TR0   = 1;
  17   1              // 装载——4ms = 4000us
  18   1              TH0   = (65536 - 4000) / 256;
  19   1              TL0   = (65536 - 4000) % 256;
  20   1              // 打开两个中断开关
  21   1              EA    = 1;
  22   1              ET0   = 1;
  23   1      }
  24          
  25          // 扫描哪个按键按下了
  26          uchar MatrixKeyScan()
  27          {
  28   1              uchar i, j, keyVal = 0;
  29   1              
  30   1              for(i = 0; i < 4; i++)
  31   1              {
  32   2                      for(j = 0; j < 4; j++)
  33   2                      {
  34   3                              // 当前按键点位值和之前时刻点位值发生变化
  35   3                              if(MatrixKeyCur[i][j] != MatrixKeyPre[i][j])
  36   3                              {
  37   4                                      // 之前时刻的点位值为高
  38   4                                      if(MatrixKeyPre[i][j])
  39   4                                      {
  40   5                                              /* 1    2       3       4
  41   5                             5        6       7       8
  42   5                                                 9    10      11      12
  43   5                                                 13   14      15      16 */
  44   5                                              keyVal = 4 * j + i + 1;
  45   5                                      }
  46   4                                      // 之前时刻的点位值更新
  47   4                                      MatrixKeyPre[i][j] = MatrixKeyCur[i][j];
  48   4                              }
  49   3                      }
  50   2              }
  51   1              
  52   1              return(keyVal);
  53   1      }
  54          
C51 COMPILER V9.57.0.0   MATRIX_KEY                                                        06/02/2020 20:38:17 PAGE 2   

  55          // 按键检测，4次扫描状态一样才是置位
  56          void MatrixKeyUpdate()
  57          {
  58   1              uchar i, j;
  59   1              
  60   1              for(i = 0; i < 4; i++)
  61   1              {
  62   2                      // 1110 1111, 1101 1111, 1011 1111, 0111 1111
  63   2                      MATRIXKEYS = Col_Sel[i];
  64   2                      
  65   2                      for(j = 0; j < 4; j++)
  66   2                      {
  67   3                              // 把KEYS的值装载到KeyBuff的最后一位
  68   3                              MatrixKeyBuff[i][j] = (MatrixKeyBuff[i][j] << 1) | (MATRIXKEYS >> j & 0x01);
  69   3                      }
  70   2                      
  71   2                      for(j = 0; j < 4; j++)
  72   2                      {                       
  73   3                              // 表明连续抽检到4个0
  74   3                              if((MatrixKeyBuff[i][j] & 0x0F) == 0x00)
  75   3                              {
  76   4                                      MatrixKeyCur[i][j] = 0;
  77   4                              }
  78   3                              // 表明连续抽检到4个1
  79   3                              else if((MatrixKeyBuff[i][j] & 0x0F) == 0x0F)
  80   3                              {
  81   4                                      MatrixKeyCur[i][j] = 1;
  82   4                              }
  83   3                      }
  84   2              }
  85   1      }
  86          
  87          void MatrixKeyInit()
  88          {
  89   1              TINT0_Init();
  90   1      }
  91          
  92          void TINT0_4ms() interrupt 1
  93          {
  94   1              // 重装载——4ms
  95   1              TH0 = (65536 - 4000) / 256;
  96   1              TL0 = (65536 - 4000) % 256;
  97   1              MatrixKeyUpdate();
  98   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    238    ----
   CONSTANT SIZE    =      4    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     48    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
=======
C51 COMPILER V9.57.0.0   MATRIX_KEY                                                        06/02/2020 20:38:17 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MATRIX_KEY
OBJECT MODULE PLACED IN ..\OBJ\matrix_key.obj
COMPILER INVOKED BY: e:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\matrix_key.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\HARDWARE) DE
                    -BUG OBJECTEXTEND PRINT(.\Listings\matrix_key.lst) OBJECT(..\OBJ\matrix_key.obj)

line level    source

   1          #include "matrix_key.h"
   2          
   3          // 装载当前时刻按键状态值
   4          uchar MatrixKeyCur[4][4]  = {1};
   5          // 装载之前时刻按键状态值
   6          uchar MatrixKeyPre[4][4]  = {1};
   7          // 四次按键扫描缓冲
   8          uchar MatrixKeyBuff[4][4] = {0xFF};
   9          uchar code Col_Sel[4] = {0xEF, 0xDF, 0xBF, 0x7F};
  10          
  11          void TINT0_Init()
  12          {
  13   1              // 方式1
  14   1              TMOD |= 0x01;
  15   1              // 打开定时器0
  16   1              TR0   = 1;
  17   1              // 装载——4ms = 4000us
  18   1              TH0   = (65536 - 4000) / 256;
  19   1              TL0   = (65536 - 4000) % 256;
  20   1              // 打开两个中断开关
  21   1              EA    = 1;
  22   1              ET0   = 1;
  23   1      }
  24          
  25          // 扫描哪个按键按下了
  26          uchar MatrixKeyScan()
  27          {
  28   1              uchar i, j, keyVal = 0;
  29   1              
  30   1              for(i = 0; i < 4; i++)
  31   1              {
  32   2                      for(j = 0; j < 4; j++)
  33   2                      {
  34   3                              // 当前按键点位值和之前时刻点位值发生变化
  35   3                              if(MatrixKeyCur[i][j] != MatrixKeyPre[i][j])
  36   3                              {
  37   4                                      // 之前时刻的点位值为高
  38   4                                      if(MatrixKeyPre[i][j])
  39   4                                      {
  40   5                                              /* 1    2       3       4
  41   5                             5        6       7       8
  42   5                                                 9    10      11      12
  43   5                                                 13   14      15      16 */
  44   5                                              keyVal = 4 * j + i + 1;
  45   5                                      }
  46   4                                      // 之前时刻的点位值更新
  47   4                                      MatrixKeyPre[i][j] = MatrixKeyCur[i][j];
  48   4                              }
  49   3                      }
  50   2              }
  51   1              
  52   1              return(keyVal);
  53   1      }
  54          
C51 COMPILER V9.57.0.0   MATRIX_KEY                                                        06/02/2020 20:38:17 PAGE 2   

  55          // 按键检测，4次扫描状态一样才是置位
  56          void MatrixKeyUpdate()
  57          {
  58   1              uchar i, j;
  59   1              
  60   1              for(i = 0; i < 4; i++)
  61   1              {
  62   2                      // 1110 1111, 1101 1111, 1011 1111, 0111 1111
  63   2                      MATRIXKEYS = Col_Sel[i];
  64   2                      
  65   2                      for(j = 0; j < 4; j++)
  66   2                      {
  67   3                              // 把KEYS的值装载到KeyBuff的最后一位
  68   3                              MatrixKeyBuff[i][j] = (MatrixKeyBuff[i][j] << 1) | (MATRIXKEYS >> j & 0x01);
  69   3                      }
  70   2                      
  71   2                      for(j = 0; j < 4; j++)
  72   2                      {                       
  73   3                              // 表明连续抽检到4个0
  74   3                              if((MatrixKeyBuff[i][j] & 0x0F) == 0x00)
  75   3                              {
  76   4                                      MatrixKeyCur[i][j] = 0;
  77   4                              }
  78   3                              // 表明连续抽检到4个1
  79   3                              else if((MatrixKeyBuff[i][j] & 0x0F) == 0x0F)
  80   3                              {
  81   4                                      MatrixKeyCur[i][j] = 1;
  82   4                              }
  83   3                      }
  84   2              }
  85   1      }
  86          
  87          void MatrixKeyInit()
  88          {
  89   1              TINT0_Init();
  90   1      }
  91          
  92          void TINT0_4ms() interrupt 1
  93          {
  94   1              // 重装载——4ms
  95   1              TH0 = (65536 - 4000) / 256;
  96   1              TL0 = (65536 - 4000) % 256;
  97   1              MatrixKeyUpdate();
  98   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    238    ----
   CONSTANT SIZE    =      4    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     48    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
>>>>>>> 64c192fc79434a4be878e64dcbbf3fda3a7e4b5e
