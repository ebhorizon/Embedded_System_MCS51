<<<<<<< HEAD
C51 COMPILER V9.57.0.0   KEY                                                               05/30/2020 17:08:07 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN ..\OBJ\key.obj
COMPILER INVOKED BY: e:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\key.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\HARDWARE) DEBUG OBJ
                    -ECTEXTEND PRINT(.\Listings\key.lst) OBJECT(..\OBJ\key.obj)

line level    source

   1          #include "key.h"
   2          
   3          uchar KeyCur[8]  = {1};         // 装载当前时刻按键状态值
   4          uchar KeyPre[8]  = {1};         // 装载之前时刻按键状态值
   5          uchar KeyBuff[8] = {0xFF};
   6          
   7          void TINT0_Init()
   8          {
   9   1              // 方式1
  10   1              TMOD |= 0x01;
  11   1              // 打开定时器0
  12   1              TR0   = 1;
  13   1              // 装载——4ms
  14   1              TH0   = (65536 - 4000) / 256;
  15   1              TL0   = (65536 - 4000) % 256;
  16   1              // 打开中断
  17   1              EA    = 1;
  18   1              ET0   = 1;
  19   1      }
  20          
  21          // 扫描哪个按键按下了
  22          uchar KeyScan()
  23          {
  24   1              uchar i, keyVal = 0;
  25   1              
  26   1              for(i = 0; i < 8; i++)
  27   1              {
  28   2                      // 当前按键点位值和之前时刻点位值发生变化
  29   2                      if(KeyCur[i] != KeyPre[i])
  30   2                      {
  31   3                              // 之前时刻的点位值为高
  32   3                              if(KeyPre[i])
  33   3                              {
  34   4                                      keyVal = i + 1;
  35   4                              }
  36   3                              // 之前时刻的点位值更新
  37   3                              KeyPre[i] = KeyCur[i];
  38   3                      }
  39   2              }
  40   1              
  41   1              return(keyVal);
  42   1      }
  43          
  44          // 按键检测，4次扫描状态一样才是置位
  45          void KeyUpdate()
  46          {
  47   1              uchar i;
  48   1              
  49   1              for(i = 0; i < 8; i++)
  50   1              {
  51   2                      // 把KEYS的值装载到KeyBuff的最后一位
  52   2                      KeyBuff[i] = (KeyBuff[i] << 1) | (KEYS >> i & 0x01);
  53   2              }
  54   1              
C51 COMPILER V9.57.0.0   KEY                                                               05/30/2020 17:08:07 PAGE 2   

  55   1              for(i = 0; i < 8; i++)
  56   1              {
  57   2                      // 表明连续抽检到4个0
  58   2                      if((KeyBuff[i] & 0x0F) == 0x00)
  59   2                      {
  60   3                              KeyCur[i] = 0;
  61   3                      }
  62   2                      // 表明连续抽检到4个1
  63   2                      else if((KeyBuff[i] & 0x0F) == 0x0F)
  64   2                      {
  65   3                              KeyCur[i] = 1;
  66   3                      }
  67   2              }
  68   1      }
  69          
  70          void KeyInit()
  71          {
  72   1              TINT0_Init();
  73   1      }
  74          
  75          void TINT_4ms() interrupt 1
  76          {
  77   1              // 重装载——4ms
  78   1              TH0 = (65536 - 4000) / 256;
  79   1              TL0 = (65536 - 4000) % 256;
  80   1              KeyUpdate();
  81   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    160    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
=======
C51 COMPILER V9.57.0.0   KEY                                                               05/30/2020 17:08:07 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN ..\OBJ\key.obj
COMPILER INVOKED BY: e:\Keil_v5\C51\BIN\C51.EXE ..\HARDWARE\key.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\HARDWARE) DEBUG OBJ
                    -ECTEXTEND PRINT(.\Listings\key.lst) OBJECT(..\OBJ\key.obj)

line level    source

   1          #include "key.h"
   2          
   3          uchar KeyCur[8]  = {1};         // 装载当前时刻按键状态值
   4          uchar KeyPre[8]  = {1};         // 装载之前时刻按键状态值
   5          uchar KeyBuff[8] = {0xFF};
   6          
   7          void TINT0_Init()
   8          {
   9   1              // 方式1
  10   1              TMOD |= 0x01;
  11   1              // 打开定时器0
  12   1              TR0   = 1;
  13   1              // 装载——4ms
  14   1              TH0   = (65536 - 4000) / 256;
  15   1              TL0   = (65536 - 4000) % 256;
  16   1              // 打开中断
  17   1              EA    = 1;
  18   1              ET0   = 1;
  19   1      }
  20          
  21          // 扫描哪个按键按下了
  22          uchar KeyScan()
  23          {
  24   1              uchar i, keyVal = 0;
  25   1              
  26   1              for(i = 0; i < 8; i++)
  27   1              {
  28   2                      // 当前按键点位值和之前时刻点位值发生变化
  29   2                      if(KeyCur[i] != KeyPre[i])
  30   2                      {
  31   3                              // 之前时刻的点位值为高
  32   3                              if(KeyPre[i])
  33   3                              {
  34   4                                      keyVal = i + 1;
  35   4                              }
  36   3                              // 之前时刻的点位值更新
  37   3                              KeyPre[i] = KeyCur[i];
  38   3                      }
  39   2              }
  40   1              
  41   1              return(keyVal);
  42   1      }
  43          
  44          // 按键检测，4次扫描状态一样才是置位
  45          void KeyUpdate()
  46          {
  47   1              uchar i;
  48   1              
  49   1              for(i = 0; i < 8; i++)
  50   1              {
  51   2                      // 把KEYS的值装载到KeyBuff的最后一位
  52   2                      KeyBuff[i] = (KeyBuff[i] << 1) | (KEYS >> i & 0x01);
  53   2              }
  54   1              
C51 COMPILER V9.57.0.0   KEY                                                               05/30/2020 17:08:07 PAGE 2   

  55   1              for(i = 0; i < 8; i++)
  56   1              {
  57   2                      // 表明连续抽检到4个0
  58   2                      if((KeyBuff[i] & 0x0F) == 0x00)
  59   2                      {
  60   3                              KeyCur[i] = 0;
  61   3                      }
  62   2                      // 表明连续抽检到4个1
  63   2                      else if((KeyBuff[i] & 0x0F) == 0x0F)
  64   2                      {
  65   3                              KeyCur[i] = 1;
  66   3                      }
  67   2              }
  68   1      }
  69          
  70          void KeyInit()
  71          {
  72   1              TINT0_Init();
  73   1      }
  74          
  75          void TINT_4ms() interrupt 1
  76          {
  77   1              // 重装载——4ms
  78   1              TH0 = (65536 - 4000) / 256;
  79   1              TL0 = (65536 - 4000) % 256;
  80   1              KeyUpdate();
  81   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    160    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     24    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
>>>>>>> 64c192fc79434a4be878e64dcbbf3fda3a7e4b5e
